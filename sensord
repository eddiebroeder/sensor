#!/usr/bin/perl
use strict;
use warnings;
$|++;

use Device::BCM2835;
use Net::SMTPS;
use DateTime;
use Getopt::Std;
use Fcntl;
use POSIX qw(mkfifo);

use vars qw($opt_t $opt_h);
getopts("th");
exit &printUsage if $opt_h;

my $AUTH_FILE = "/home/embroede/sensor/authFile";
my $CGI_TO_SENSORD_PIPE = "/tmp/cgi_to_sensord.pipe";
my $SENSORD_TO_CGI_PIPE = "/tmp/sensord_to_cgi.pipe";
my $MOTION_THRESHOLD = 3;
my $CGI_TO_SENSORD_FH;

&exitIfRunning();
&ensurePipesExist();
&initializeIO();
$SIG{TERM} = \&handleTermSignal;

&printLog("Starting sensor (armed)");
 
my %credentials = &getCredentials($AUTH_FILE);
my $armed = 1;
my $motionCount = 0;
while (1)
{
    my $action = &readPipe();
    if ($action eq "arm") {
        &armSensor();
    }
    elsif ($action eq "disarm") {
        &disarmSensor();
    }
    elsif ($action eq "status") {
        &writeStatus();
    }
    if ($armed) {
        my $motion = Device::BCM2835::gpio_lev(&Device::BCM2835::RPI_GPIO_P1_08);
        ($motion) ? $motionCount++ : ($motionCount = 0);
        if ($motionCount > $MOTION_THRESHOLD) {
            &printLog("MOTION DETECTED!");
            &handleMotion();
            &printLog("sleeping 20 seconds");
            sleep 20;
        }
        select(undef, undef, undef, 0.20);
    }
    else {
        sleep 5;
    }
}

#---< subroutines >------------------------------------------------------------

sub initializeIO() {
    Device::BCM2835::init() or &printLogAndExit("Could not initialize BCM2835 library");
    Device::BCM2835::gpio_fsel(&Device::BCM2835::RPI_GPIO_P1_08, &Device::BCM2835::BCM2835_GPIO_FSEL_INPT);
    sysopen ($CGI_TO_SENSORD_FH, $CGI_TO_SENSORD_PIPE, O_NONBLOCK|O_RDONLY) or &printLog("Couldn't open pipe $CGI_TO_SENSORD_PIPE, $!");
}

sub cleanupIO() {
    #TODO: figure out how to cleanup gpio pins
    close ($CGI_TO_SENSORD_FH) or &printLog("Couldn't close pipe $CGI_TO_SENSORD_PIPE");
}

sub handleMotion() {
    return if $opt_t;
    my $time = DateTime->now(time_zone => "America/Los_Angeles");
    &printLog("Taking photo");
    `/usr/bin/raspistill -o /var/www/sensor/photos/$time -rot 270 -q 100 -t 2000`;
    &sendEmail($time) or &printLog("Couldn't send email");
    &printLog("recording video");
    `/home/embroede/sensor/record20SecondClip $time`;
}

sub sendEmail() {
    my $time = shift;
    &printLog("Sending email and text message");
    my $smtp = Net::SMTP->new(
        Host        => "smtp.mail.yahoo.com",
        Port        => 587,
        Timeout     => 10,
        doSSL       => "starttls",
        SSL_version => "TLSv1",
    ) or &printLog("couldn't create smtp object");
    $smtp->starttls();
    $smtp->auth($credentials{user}, $credentials{pass});
    $smtp->mail($credentials{fromAddress});
    $smtp->cc($credentials{toAddress});
    $smtp->to($credentials{toNumber});
    $smtp->data();
    $smtp->datasend("\nMotion Detected!\n");
    $smtp->datasend("Links to current photo/video:\n");
    $smtp->datasend($credentials{domain} . "/photos/$time\n");
    $smtp->datasend($credentials{domain} . "/videos/$time.mp4");
    $smtp->datasend();
    my $smtpStatus = $smtp->quit();
    &printLog("SMTP send status (1 doesn't always mean good): $smtpStatus");
}

sub getCredentials() {
    my $authFile = shift;
    my %credentials;
    open (my $FH, "<", $authFile) or &printLogAndExit("Couldn't open authFile, $!");
    while (<$FH>) {
        chomp;
        $credentials{fromAddress} = (split(/=/,$_))[1] if $_ =~ /^fromAddress/;
        $credentials{user} = (split(/=/,$_))[1] if $_ =~ /^user/;
        $credentials{pass} = (split(/=/,$_))[1] if $_ =~ /^password/;
        $credentials{toAddress} = (split(/=/,$_))[1] if $_ =~ /^toAddress/;
        $credentials{toNumber} = (split(/=/,$_))[1] if $_ =~ /^toNumber/;
        $credentials{domain} = (split(/=/,$_))[1] if $_ =~ /^domain/;
    }
    close ($FH) or &printLogAndExit("Couldn't close authFile");
    return %credentials;
}

sub armSensor() {
    &writePipe("armed");
    if ($armed) {
        &printLog("Received arm signal (already armed)");
    }
    else {
        $armed = 1;
        &printLog("Received arm signal, sensor is now armed");
    }
}

sub disarmSensor() {
    &writePipe("disarmed");
    if ($armed) {
        $armed = 0;
        &printLog("Received disarm signal, sensor is now disarmed");
    }
    else {
        &printLog("Received disarm signal (already disarmed)");
    }
}

sub writeStatus() {
        ($armed) ? &writePipe("armed") : &writePipe("disarmed");
        &printLog("Received status query, writing status to pipe");
}

sub ensurePipesExist() {
    unless (-p $SENSORD_TO_CGI_PIPE) {
        my $return = mkfifo ($SENSORD_TO_CGI_PIPE, "0666"); #FIXME: This mode doesn't work, even though my umask is 0000
        &printLog("Creating PIPE $SENSORD_TO_CGI_PIPE");
        &printLogAndExit("Couldn't create PIPE $SENSORD_TO_CGI_PIPE, $!") unless $return;
        chmod (0666, $SENSORD_TO_CGI_PIPE);
    }
    unless (-p $CGI_TO_SENSORD_PIPE) {
        my $return = mkfifo ($CGI_TO_SENSORD_PIPE, "0666"); #FIXME: This mode doesn't work, even though my umask is 0000
        &printLog("Creating PIPE $CGI_TO_SENSORD_PIPE");
        &printLogAndExit("Couldn't create PIPE $CGI_TO_SENSORD_PIPE, $!") unless $return;
        chmod (0666, $CGI_TO_SENSORD_PIPE);
    }
}

sub readPipe() {
    my $output;
    my $return = sysread ($CGI_TO_SENSORD_FH, $output, 6); #TODO: CHECK RETURN
    return $output;
}

sub writePipe() {
    my $msg = shift;
    system("/bin/echo $msg > $SENSORD_TO_CGI_PIPE &"); # Not ideal; works for now
    return;
}

sub printLog() {
    my $msg = shift;
    my $time = DateTime->now(time_zone => "America/Los_Angeles");
    print "$time $msg\n";
}

sub printLogAndExit() {
    my $msg = shift;
    &printLog($msg);
    &printLog("Terminating program");
    exit -1;
}

sub exitIfRunning() {
    my @output = `pgrep sensord`;
    if (scalar @output > 1) {
        print "sensord is already running, exiting...\n";
        exit -1;
    }
}

sub handleTermSignal() {
    &printLog("Caught TERM signal, terminating program");
    &cleanupIO();
    exit 0;
}

sub printUsage() {
    print <<EOF
Usage: sensord [OPTION]...
Monitors an area for motion, and sends a notification with
a link to picture and video if motion is detected.

  -t    Test mode (dry run with no notification)
  -h    Display this help and exit

EOF
}

